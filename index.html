<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Jogo 1x1 P2P com WebRTC</title>
  <style>
    canvas { border: 1px solid black; }
    #linkArea, #answerArea, #sdpInput, #connectBtn { margin: 10px; }
    textarea { font-family: monospace; width: 100%; max-width: 600px; }
    button:disabled { opacity: 0.5; }
    #status { color: red; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div>
    <button id="generateLink">Gerar Link de Convite (Host)</button>
    <br>
    <textarea id="linkArea" rows="4" readonly placeholder="Link de convite aparecerá aqui (Host)"></textarea>
    <br>
    <textarea id="answerArea" rows="4" readonly placeholder="Resposta SDP aparecerá aqui (Peer)"></textarea>
    <br>
    <textarea id="sdpInput" rows="4" placeholder="Cole o SDP do adversário aqui"></textarea>
    <br>
    <button id="connectBtn">Conectar ao Adversário</button>
    <div id="status"></div>
  </div>

  <script>
    // Configuração do canvas
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');

    // Estado do jogador
    const player = { x: 50, y: 350, width: 20, height: 20, vy: 0, jumping: false };
    const opponent = { x: 700, y: 350, width: 20, height: 20 };
    const gravity = 0.5;
    const jumpForce = -10;
    const moveSpeed = 5;

    // WebRTC
    let peerConnection = null;
    let dataChannel = null;
    const isHost = !window.location.hash.includes('join');

    // Configuração WebRTC com STUN
    const configuration = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
        // Opcional: Adicione TURN se necessário (exige credenciais)
      ]
    };

    function setupWebRTC() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }

      peerConnection = new RTCPeerConnection(configuration);
      updateStatus('WebRTC inicializado.');

      if (isHost) {
        dataChannel = peerConnection.createDataChannel('gameChannel');
        setupDataChannel(dataChannel);
      }

      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel(dataChannel);
      };

      peerConnection.onicecandidate = (event) => {
        if (event.candidate === null && peerConnection.localDescription) {
          const sdp = btoa(JSON.stringify(peerConnection.localDescription));
          if (isHost) {
            const link = `${window.location.origin}${window.location.pathname}#join=${encodeURIComponent(sdp)}`;
            document.getElementById('linkArea').value = link;
            updateStatus('Link de convite gerado. Copie e envie ao adversário.');
          } else {
            document.getElementById('answerArea').value = sdp;
            updateStatus('Resposta SDP gerada. Copie e envie ao host.');
          }
        }
      };

      peerConnection.onconnectionstatechange = () => {
        console.log('Estado da conexão:', peerConnection.connectionState);
        updateStatus(`Estado da conexão: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'failed') {
          updateStatus('Falha na conexão. Tente novamente.');
          resetConnection();
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log('Estado ICE:', peerConnection.iceConnectionState);
        if (peerConnection.iceConnectionState === 'disconnected') {
          updateStatus('Conexão perdida.');
          resetConnection();
        }
      };
    }

    function setupDataChannel(channel) {
      channel.onopen = () => {
        console.log('Canal de dados aberto!');
        updateStatus('Conexão estabelecida! Jogo iniciado.');
        document.getElementById('connectBtn').disabled = true;
        document.getElementById('generateLink').disabled = true;
        document.getElementById('sdpInput').disabled = true;
        gameLoop();
      };
      channel.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          opponent.x = data.x;
          opponent.y = data.y;
        } catch (err) {
          console.error('Erro ao processar mensagem:', err);
        }
      };
      channel.onclose = () => {
        console.log('Canal de dados fechado.');
        updateStatus('Conexão fechada.');
        resetConnection();
      };
      channel.onerror = (err) => {
        console.error('Erro no canal:', err);
        updateStatus('Erro na conexão.');
      };
    }

    function resetConnection() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }
      document.getElementById('connectBtn').disabled = false;
      document.getElementById('generateLink').disabled = !isHost;
      document.getElementById('sdpInput').disabled = false;
      document.getElementById('linkArea').value = '';
      document.getElementById('answerArea').value = '';
      document.getElementById('sdpInput').value = '';
    }

    function updateStatus(message) {
      statusDiv.textContent = message;
    }

    // Gerar oferta (host)
    document.getElementById('generateLink').addEventListener('click', async () => {
      if (!isHost) return;
      document.getElementById('linkArea').value = '';
      document.getElementById('answerArea').value = '';
      setupWebRTC();
      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        console.log('Oferta criada. Estado:', peerConnection.signalingState);
      } catch (err) {
        console.error('Erro ao gerar oferta:', err);
        updateStatus('Erro ao gerar oferta: ' + err.message);
      }
    });

    // Conectar ao adversário
    document.getElementById('connectBtn').addEventListener('click', async () => {
      const sdpInput = document.getElementById('sdpInput').value.trim();
      if (!sdpInput) {
        updateStatus('Por favor, cole um SDP válido.');
        return;
      }

      try {
        let sdp;
        try {
          sdp = JSON.parse(atob(sdpInput));
          if (!sdp.type || !sdp.sdp) {
            throw new Error('Formato de SDP inválido.');
          }
        } catch (err) {
          updateStatus('SDP inválido. Certifique-se de colar um SDP codificado em base64 válido.');
          console.error('Erro ao decodificar SDP:', err);
          return;
        }

        if (!peerConnection) {
          setupWebRTC();
        }

        console.log('Estado antes de setRemoteDescription:', peerConnection.signalingState);

        // Validação de estado
        if (isHost && peerConnection.signalingState !== 'have-local-offer') {
          updateStatus('Erro: O host deve gerar uma oferta primeiro.');
          return;
        }
        if (!isHost && peerConnection.signalingState !== 'stable') {
          updateStatus('Erro: Reinicie a conexão.');
          setupWebRTC();
        }

        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));
        console.log('Descrição remota definida. Estado:', peerConnection.signalingState);

        if (!isHost) {
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
          console.log('Resposta criada. Estado:', peerConnection.signalingState);
        }
      } catch (err) {
        console.error('Erro ao conectar:', err);
        updateStatus(`Erro ao conectar: ${err.message}`);
      }
    });

    // Inicializar peer com SDP do link
    if (!isHost) {
      document.getElementById('generateLink').disabled = true;
      const sdpEncoded = window.location.hash.split('join=')[1];
      if (sdpEncoded) {
        try {
          const sdp = JSON.parse(atob(decodeURIComponent(sdpEncoded)));
          document.getElementById('sdpInput').value = btoa(JSON.stringify(sdp));
          updateStatus('SDP do link carregado. Clique em "Conectar" para prosseguir.');
        } catch (err) {
          console.error('Erro ao decodificar SDP do link:', err);
          updateStatus('Erro ao carregar SDP do link. Cole o SDP manualmente.');
        }
      }
    }

    // Controles do jogador
    document.addEventListener('keydown', (e) => {
      if (e.key === 'w' && !player.jumping) {
        player.vy = jumpForce;
        player.jumping = true;
      } else if (e.key === 'a') {
        player.x -= moveSpeed;
      } else if (e.key === 'd') {
        player.x += moveSpeed;
      }
      player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
    });

    // Loop do jogo
    function gameLoop() {
      // Física
      player.vy += gravity;
      player.y += player.vy;
      if (player.y > canvas.height - player.height) {
        player.y = canvas.height - player.height;
        player.vy = 0;
        player.jumping = false;
      }

      // Enviar posição
      if (dataChannel && dataChannel.readyState === 'open') {
        try {
          dataChannel.send(JSON.stringify({ x: player.x, y: player.y }));
        } catch (err) {
          console.error('Erro ao enviar dados:', err);
        }
      }

      // Desenhar
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'blue';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.fillStyle = 'red';
      ctx.fillRect(opponent.x, opponent.y, opponent.width, opponent.height);

      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>