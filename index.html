<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Jogo 1x1 P2P com WebRTC</title>
  <style>
    canvas { border: 1px solid black; }
    #linkArea, #linkArea2, #sdpInput, #connectBtn { margin: 10px; }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>
  <div>
    <button id="generateLink">Gerar Link de Convite</button>
    <br>
    <textarea id="linkArea" rows="4" cols="50" readonly placeholder="Link de convite aparecerá aqui"></textarea>
    <br>
    <textarea id="linkArea2" rows="4" cols="50" readonly placeholder="Link de resposta aparecerá aqui"></textarea>
    <br>
    <textarea id="sdpInput" rows="4" cols="50" placeholder="Cole o SDP do adversário aqui"></textarea>
    <br>
    <button id="connectBtn">Conectar ao Adversário</button>
  </div>

  <script>
    // Configuração do canvas
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // Estado do jogador
    const player = { x: 50, y: 350, width: 20, height: 20, vy: 0, jumping: false };
    const opponent = { x: 700, y: 350, width: 20, height: 20 };
    const gravity = 0.5;
    const jumpForce = -10;
    const moveSpeed = 5;

    // WebRTC
    let peerConnection = null;
    let dataChannel = null;
    const isHost = !window.location.hash.includes('join');

    // Configuração WebRTC
    function setupWebRTC() {
      // Fechar conexão existente, se houver
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
        dataChannel = null;
      }

      peerConnection = new RTCPeerConnection();

      // Criar canal de dados (se for host)
      if (isHost) {
        dataChannel = peerConnection.createDataChannel('gameChannel');
        setupDataChannel(dataChannel);
      }

      // Quando receber o canal de dados (se for peer)
      peerConnection.ondatachannel = (event) => {
        dataChannel = event.channel;
        setupDataChannel(dataChannel);
      };

      // Gerenciar ICE candidates
      peerConnection.onicecandidate = (event) => {
        if (event.candidate === null) {
          if (isHost) {
            const sdp = btoa(JSON.stringify(peerConnection.localDescription));
            const link = `${window.location.origin}${window.location.pathname}#join=${sdp}`;
            document.getElementById('linkArea').value = link;
          } else {
            // Para o peer, exibir a resposta SDP
            const sdp = btoa(JSON.stringify(peerConnection.localDescription));
            const link = `${window.location.origin}${window.location.pathname}#answer=${sdp}`;
            document.getElementById('linkArea2').value = link;
          }
        }
      };
    }

    // Configurar canal de dados
    function setupDataChannel(channel) {
      channel.onopen = () => {
        console.log('Canal de dados aberto!');
        gameLoop();
      };
      channel.onmessage = (event) => {
        const data = JSON.parse(event.data);
        opponent.x = data.x;
        opponent.y = data.y;
      };
      channel.onclose = () => {
        console.log('Canal de dados fechado.');
      };
    }

    // Gerar oferta (host)
    document.getElementById('generateLink').addEventListener('click', async () => {
      if (!isHost) return;
      setupWebRTC();
      try {
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
      } catch (err) {
        console.error('Erro ao gerar oferta:', err);
      }
    });

    // Conectar ao adversário
    document.getElementById('connectBtn').addEventListener('click', async () => {
      const sdpInput = document.getElementById('sdpInput').value.trim();
      if (!sdpInput) {
        alert('Por favor, cole um SDP válido.');
        return;
      }

      try {
        let sdp;
        try {
          sdp = JSON.parse(atob(sdpInput));
        } catch (err) {
          alert('SDP inválido. Certifique-se de colar um SDP codificado em base64 válido.');
          return;
        }

        // Inicializar WebRTC se não estiver inicializado
        if (!peerConnection) {
          setupWebRTC();
        }

        // Verificar estado da conexão
        if (peerConnection.signalingState === 'stable' && isHost) {
          console.warn('Conexão já está estável. Reinicie para nova conexão.');
          alert('Conexão já estabelecida. Reinicie o processo se deseja conectar novamente.');
          return;
        }

        // Definir descrição remota
        await peerConnection.setRemoteDescription(new RTCSessionDescription(sdp));

        // Criar resposta se for peer
        if (!isHost) {
          const answer = await peerConnection.createAnswer();
          await peerConnection.setLocalDescription(answer);
        }
      } catch (err) {
        console.error('Erro ao conectar:', err);
        alert(`Erro: ${err.message}`);
      }
    });

    // Inicializar peer com SDP do link, se houver
    if (!isHost) {
      document.getElementById('generateLink').disabled = true;
      const sdpEncoded = window.location.hash.split('join=')[1];
      if (sdpEncoded) {
        try {
          const sdp = JSON.parse(atob(decodeURIComponent(sdpEncoded)));
          document.getElementById('sdpInput').value = btoa(JSON.stringify(sdp));
        } catch (err) {
          console.error('Erro ao decodificar SDP do link:', err);
        }
      }
    }

    // Controles do jogador
    document.addEventListener('keydown', (e) => {
      if (e.key === 'w' && !player.jumping) {
        player.vy = jumpForce;
        player.jumping = true;
      } else if (e.key === 'a') {
        player.x -= moveSpeed;
      } else if (e.key === 'd') {
        player.x += moveSpeed;
      }
      player.x = Math.max(0, Math.min(player.x, canvas.width - player.width));
    });

    // Loop do jogo
    function gameLoop() {
      // Física
      player.vy += gravity;
      player.y += player.vy;
      if (player.y > canvas.height - player.height) {
        player.y = canvas.height - player.height;
        player.vy = 0;
        player.jumping = false;
      }

      // Enviar posição
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify({ x: player.x, y: player.y }));
      }

      // Desenhar
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'blue';
      ctx.fillRect(player.x, player.y, player.width, player.height);
      ctx.fillStyle = 'red';
      ctx.fillRect(opponent.x, opponent.y, opponent.width, opponent.height);

      requestAnimationFrame(gameLoop);
    }
  </script>
</body>
</html>